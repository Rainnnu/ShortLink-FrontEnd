{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport axios from \"axios\";\n\n// 创建一个axios对象出来\nconst request = axios.create({\n  baseURL: \"http://8.138.124.114:9766/sparrow/api\",\n  timeout: 60000\n});\n\n// request 拦截器\n// 可以自请求发送前对请求做一些处理\n// 比如统一加token，对请求参数统一加密\nrequest.interceptors.request.use(config => {\n  console.log(config);\n  config.headers[\"Content-Type\"] = \"application/json;charset=utf-8\";\n  // 从本地存储中获取 accessToken\n  const accessToken = localStorage.getItem(\"accessToken\");\n  const accessToken2 = localStorage.getItem(\"templeAccessToken\"); //临时token\n\n  if ((config.url.includes(\"/users/loginByPassword\") || config.url.includes(\"/users/loginByEmail\")) && accessToken) {\n    // 设置请求头\n    config.headers[\"accessToken\"] = `${accessToken}`; //后端要求为accessToken\n  }\n  if (config.url === \"/users/resetPassword\" && accessToken2) {\n    config.headers[\"accessToken\"] = `${accessToken2}`; //后端要求为accessToken\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// response 拦截器\n// 可以在接口响应后统一处理结果\nlet isRefreshing = false;\nlet requests = [];\nrequest.interceptors.response.use(response => {\n  // response.data即为后端返回的Result\n  let res = response.data;\n  // 兼容服务端返回的字符串数据\n  if (typeof res === \"string\") {\n    res = res ? JSON.parse(res) : res;\n  }\n  return res;\n}, async error => {\n  const {\n    config,\n    response\n  } = error;\n  if (response && response.status === 401) {\n    if (!isRefreshing) {\n      isRefreshing = true;\n      try {\n        // 从本地存储中获取 refreshToken\n        const refreshToken = localStorage.getItem(\"refreshToken\");\n        if (refreshToken) {\n          // 发送刷新 token 的请求\n          const refreshResponse = await axios.post(`${request.defaults.baseURL}/user/refreshToken`, {\n            refreshToken\n          });\n          const {\n            accessToken,\n            newRefreshToken\n          } = refreshResponse.data;\n          // 更新本地存储的 token\n          localStorage.setItem(\"accessToken\", accessToken);\n          if (newRefreshToken) {\n            localStorage.setItem(\"refreshToken\", newRefreshToken);\n          }\n          // 重新发起之前失败的请求\n          requests.forEach(cb => cb(accessToken));\n          requests = [];\n          return request(config);\n        }\n      } catch (refreshError) {\n        // 刷新 token 失败，清除本地存储的 token 并跳转到登录页\n        localStorage.removeItem(\"accessToken\");\n        localStorage.removeItem(\"refreshToken\");\n        // 这里需要根据你的项目实际情况进行跳转登录页的操作\n        // 例如在 Vue 项目中可以使用 this.$router.push('/login')\n        console.log(\"刷新 token 失败，跳转到登录页\");\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    } else {\n      // 正在刷新 token，将请求挂起\n      return new Promise(resolve => {\n        requests.push(accessToken => {\n          config.headers[\"Authorization\"] = `${accessToken}`;\n          resolve(request(config));\n        });\n      });\n    }\n  }\n  console.log(\"err\" + error); // for debug\n  return Promise.reject(error);\n});\nexport default request;","map":{"version":3,"names":["axios","request","create","baseURL","timeout","interceptors","use","config","console","log","headers","accessToken","localStorage","getItem","accessToken2","url","includes","error","Promise","reject","isRefreshing","requests","response","res","data","JSON","parse","status","refreshToken","refreshResponse","post","defaults","newRefreshToken","setItem","forEach","cb","refreshError","removeItem","resolve","push"],"sources":["C:/Users/NNNaR/Desktop/短链/ShortLink-FrontEnd/vue/src/utils/request.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// 创建一个axios对象出来\r\nconst request = axios.create({\r\n  baseURL: \"http://8.138.124.114:9766/sparrow/api\",\r\n  timeout: 60000,\r\n});\r\n\r\n// request 拦截器\r\n// 可以自请求发送前对请求做一些处理\r\n// 比如统一加token，对请求参数统一加密\r\nrequest.interceptors.request.use(\r\n  (config) => {\r\n    console.log(config);\r\n    config.headers[\"Content-Type\"] = \"application/json;charset=utf-8\";\r\n    // 从本地存储中获取 accessToken\r\n    const accessToken = localStorage.getItem(\"accessToken\");\r\n    const accessToken2 = localStorage.getItem(\"templeAccessToken\"); //临时token\r\n\r\n    if (\r\n      (config.url.includes(\"/users/loginByPassword\") ||\r\n        config.url.includes(\"/users/loginByEmail\")) &&\r\n      accessToken\r\n    ) {\r\n      // 设置请求头\r\n      config.headers[\"accessToken\"] = `${accessToken}`; //后端要求为accessToken\r\n    }\r\n\r\n    if (config.url === \"/users/resetPassword\" && accessToken2) {\r\n      config.headers[\"accessToken\"] = `${accessToken2}`; //后端要求为accessToken\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// response 拦截器\r\n// 可以在接口响应后统一处理结果\r\nlet isRefreshing = false;\r\nlet requests = [];\r\n\r\nrequest.interceptors.response.use(\r\n  (response) => {\r\n    // response.data即为后端返回的Result\r\n    let res = response.data;\r\n    // 兼容服务端返回的字符串数据\r\n    if (typeof res === \"string\") {\r\n      res = res ? JSON.parse(res) : res;\r\n    }\r\n    return res;\r\n  },\r\n  async (error) => {\r\n    const { config, response } = error;\r\n    if (response && response.status === 401) {\r\n      if (!isRefreshing) {\r\n        isRefreshing = true;\r\n        try {\r\n          // 从本地存储中获取 refreshToken\r\n          const refreshToken = localStorage.getItem(\"refreshToken\");\r\n          if (refreshToken) {\r\n            // 发送刷新 token 的请求\r\n            const refreshResponse = await axios.post(\r\n              `${request.defaults.baseURL}/user/refreshToken`,\r\n              {\r\n                refreshToken,\r\n              }\r\n            );\r\n            const { accessToken, newRefreshToken } = refreshResponse.data;\r\n            // 更新本地存储的 token\r\n            localStorage.setItem(\"accessToken\", accessToken);\r\n            if (newRefreshToken) {\r\n              localStorage.setItem(\"refreshToken\", newRefreshToken);\r\n            }\r\n            // 重新发起之前失败的请求\r\n            requests.forEach((cb) => cb(accessToken));\r\n            requests = [];\r\n            return request(config);\r\n          }\r\n        } catch (refreshError) {\r\n          // 刷新 token 失败，清除本地存储的 token 并跳转到登录页\r\n          localStorage.removeItem(\"accessToken\");\r\n          localStorage.removeItem(\"refreshToken\");\r\n          // 这里需要根据你的项目实际情况进行跳转登录页的操作\r\n          // 例如在 Vue 项目中可以使用 this.$router.push('/login')\r\n          console.log(\"刷新 token 失败，跳转到登录页\");\r\n          return Promise.reject(refreshError);\r\n        } finally {\r\n          isRefreshing = false;\r\n        }\r\n      } else {\r\n        // 正在刷新 token，将请求挂起\r\n        return new Promise((resolve) => {\r\n          requests.push((accessToken) => {\r\n            config.headers[\"Authorization\"] = `${accessToken}`;\r\n            resolve(request(config));\r\n          });\r\n        });\r\n      }\r\n    }\r\n    console.log(\"err\" + error); // for debug\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default request;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}